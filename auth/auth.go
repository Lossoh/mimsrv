// The auth package implements a simple password mechanism to allow
// authentication of API calls.
// We have a database that stores two fields for each user:
// a userid and a cryptword. The cryptword is generated by concatenating
// the userid with the user's password and taking a sha256sum of that.
// For login, the user enters a userid and a password into the client,
// which generates the cryptword. It then gets the current time in seconds
// since the epoch, converts that number to a decimal string, concatenates
// the cryptword with that string, and takes the sha256sum of that, which it
// sends to the server along with the username.

package auth

import (
  "bufio"
  "crypto/sha256"
  "encoding/csv"
  "fmt"
  "log"
  "net/http"
  "os"
  "strconv"
  "syscall"
  "time"

  "golang.org/x/crypto/ssh/terminal"
)

var (
  timeNow = time.Now
)

type Config struct {
  Prefix string                 // The prefix string used for our API calls
  PasswordFilePath string       // Location of our password database file
  MaxClockSkewSeconds int
}

type Handler struct {
  ApiHandler http.Handler
  config *Config
  records [][]string
}

func NewHandler(c *Config) Handler {
  h := Handler{config: c}
  h.loadPasswordFile()
  h.initApiHandler()
  initTokens()
  return h
}

func (h *Handler) CreatePasswordFile() error {
  f, err := os.Open(h.config.PasswordFilePath)
  if err == nil || !os.IsNotExist(err) {
    return fmt.Errorf("password file already exists at %s", h.config.PasswordFilePath)
  }
  f, err = os.Create(h.config.PasswordFilePath)
  if err != nil {
    return fmt.Errorf("error creating new password file at %s: %v", h.config.PasswordFilePath, err)
  }
  f.Close()
  return nil
}

// Read a password from the terminal and pass it to UpdatePassword.
func (h *Handler) UpdateUserPassword(userid string) error {
  if !terminal.IsTerminal(syscall.Stdin) {
    return fmt.Errorf("updatePassword option requires terminal for input")
  }
  fmt.Printf("New password: ")
  pw, err := terminal.ReadPassword(syscall.Stdin)
  fmt.Printf("\n")
  if err != nil {
    return fmt.Errorf("Error reading new password: %v", err)
  }
  fmt.Printf("Repeat new password: ")
  pw2, err := terminal.ReadPassword(syscall.Stdin)
  fmt.Printf("\n")
  if err != nil {
    return fmt.Errorf("Error reading new password: %v", err)
  }
  if string(pw2) != string(pw) {
    return fmt.Errorf("Passwords did not match")
  }
  return h.UpdatePassword(userid, string(pw))
}

// Set a password for a user into our password database. We don't save the
// plaintext password, we concatenate the userid with the raw password, take
// the sha256sum of that, and store that in our database.
func (h *Handler) UpdatePassword(userid, password string) error {
  err := h.loadPasswordFile()
  if err != nil {
    return err
  }
  cryptword := h.generateCryptword(userid, password)
  err = h.setCryptword(userid, cryptword)
  if err != nil {
    return err
  }
  err = h.savePasswordFile()
  if err != nil {
    return err
  }
  return nil
}

func (h *Handler) loadPasswordFile() error {
  f, err := os.Open(h.config.PasswordFilePath)
  if err != nil {
    return fmt.Errorf("error opening password file %s: %v", h.config.PasswordFilePath, err)
  }
  r := csv.NewReader(bufio.NewReader(f))

  records, err := r.ReadAll()
  if err != nil {
    return fmt.Errorf("error loading password file %s: %v", h.config.PasswordFilePath, err)
  }

  h.records = records
  log.Printf("Number of passwd records: %v\n", len(h.records))
  return nil
}

func (h *Handler) savePasswordFile() error {
  newFilePath := h.config.PasswordFilePath + ".new"
  f, err := os.Create(newFilePath)
  if err != nil {
    return fmt.Errorf("error creating new password file %s: %v", newFilePath, err)
  }
  w := csv.NewWriter(bufio.NewWriter(f))
  err = w.WriteAll(h.records)
  if err != nil {
    return fmt.Errorf("error writing new password file %s: %v", newFilePath, err)
  }
  w.Flush()
  f.Close()

  backupFilePath := h.config.PasswordFilePath + "~"
  err = os.Rename(h.config.PasswordFilePath, backupFilePath)
  if err != nil {
    return fmt.Errorf("error moving old file to backup path %s: %v", backupFilePath, err)
  }
  err = os.Rename(newFilePath, h.config.PasswordFilePath)
  if err != nil {
    return fmt.Errorf("error moving new file %s to become active file: %v", newFilePath, err)
  }

  return nil
}

func (h *Handler) setCryptword(userid, cryptword string) error {
  for r, record := range(h.records) {
    if record[0] == userid {
      h.records[r][1] = cryptword
      return nil
    }
  }
  record := []string{userid, cryptword}
  h.records = append(h.records, record)
  return nil
}

// Get the encrypted password for the given user from our previously-loaded password file.
func (h *Handler) getCryptword(userid string) string {
  for _, record := range(h.records) {
    if record[0] == userid {
      return record[1]
    }
  }
  return ""
}

func (h *Handler) generateCryptword(userid, password string) string {
  return sha256sum(userid + "-" + password)
}

func (h *Handler) generateNonceAtTime(userid string, secondsSinceEpoch int64) string {
  cryptword := h.getCryptword(userid)
  shaInput := cryptword + "-" + strconv.FormatInt(secondsSinceEpoch, 10)
  return sha256sum(shaInput)
}

func (h *Handler) nonceIsValidAtTime(userid, nonce string, secondsSinceEpoch int64) bool {
  goodNonce := h.generateNonceAtTime(userid, secondsSinceEpoch)
  if nonce == goodNonce {
    return true
  } else {
    log.Printf("nonce %v does not match goodNonce %v", nonce, goodNonce)
    return false
  }
}

func (h *Handler) nonceIsValidNow(userid, nonce string, seconds int64) bool {
  t := timeNow().Unix()
  delta := t - seconds
  if delta > int64(h.config.MaxClockSkewSeconds) || delta < -int64(h.config.MaxClockSkewSeconds) {
    log.Printf("now=%v, client-time=%v, skew is more than max of %v",
        t, seconds, h.config.MaxClockSkewSeconds)
    return false
  }
  return h.nonceIsValidAtTime(userid, nonce, seconds)
}

func sha256sum(s string) string {
  sum := sha256.Sum256([]byte(s))
  return fmt.Sprintf("%x", sum)
}
